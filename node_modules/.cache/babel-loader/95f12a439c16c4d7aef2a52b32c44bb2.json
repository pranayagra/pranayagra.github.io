{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/prana/OneDrive/Desktop/Misc/officialwebsite/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { colorToRgb, getStyleFromRgb } from \"../../Utils/ColorUtils\";\nimport { Vector } from \"../../Core/Utils/Vector\";\nimport { getDistances } from \"../../Utils/NumberUtils\";\nexport function drawPolygonMask(context, rawData, stroke) {\n  var color = colorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.beginPath();\n  context.moveTo(rawData[0].x, rawData[0].y);\n  var _iterator = _createForOfIteratorHelper(rawData),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var item = _step.value;\n      context.lineTo(item.x, item.y);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  context.closePath();\n  context.strokeStyle = getStyleFromRgb(color);\n  context.lineWidth = stroke.width;\n  context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n  context.translate(position.x, position.y);\n  var color = colorToRgb(stroke.color);\n  if (!color) {\n    return;\n  }\n  context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n  context.lineWidth = stroke.width;\n  context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n  var _a;\n  var res = [];\n  var _iterator2 = _createForOfIteratorHelper(paths),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var path = _step2.value;\n      var segments = path.element.pathSegList,\n        len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0,\n        p = {\n          x: 0,\n          y: 0\n        };\n      for (var i = 0; i < len; i++) {\n        var segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n        var svgPathSeg = window.SVGPathSeg;\n        switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n          case svgPathSeg.PATHSEG_MOVETO_ABS:\n          case svgPathSeg.PATHSEG_LINETO_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n          case svgPathSeg.PATHSEG_ARC_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n            {\n              var absSeg = segment;\n              p.x = absSeg.x;\n              p.y = absSeg.y;\n              break;\n            }\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n            p.x = segment.x;\n            break;\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n            p.y = segment.y;\n            break;\n          case svgPathSeg.PATHSEG_LINETO_REL:\n          case svgPathSeg.PATHSEG_MOVETO_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n          case svgPathSeg.PATHSEG_ARC_REL:\n          case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n          case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n            {\n              var relSeg = segment;\n              p.x += relSeg.x;\n              p.y += relSeg.y;\n              break;\n            }\n          case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n            p.x += segment.x;\n            break;\n          case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n            p.y += segment.y;\n            break;\n          case svgPathSeg.PATHSEG_UNKNOWN:\n          case svgPathSeg.PATHSEG_CLOSEPATH:\n            continue;\n        }\n        res.push({\n          x: p.x * scale + offset.x,\n          y: p.y * scale + offset.y\n        });\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n  var _getDistances = getDistances(pos, s1),\n    dx = _getDistances.dx,\n    dy = _getDistances.dy,\n    _getDistances2 = getDistances(s2, s1),\n    dxx = _getDistances2.dx,\n    dyy = _getDistances2.dy,\n    t = (dx * dxx + dy * dyy) / (Math.pow(dxx, 2) + Math.pow(dyy, 2)),\n    res = {\n      x: s1.x + dxx * t,\n      y: s1.x + dyy * t,\n      isOnSegment: t >= 0 && t <= 1\n    };\n  if (t < 0) {\n    res.x = s1.x;\n    res.y = s1.y;\n  } else if (t > 1) {\n    res.x = s2.x;\n    res.y = s2.y;\n  }\n  return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n  var _getDistances3 = getDistances(start, stop),\n    dx = _getDistances3.dx,\n    dy = _getDistances3.dy,\n    wallAngle = Math.atan2(dy, dx),\n    wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)),\n    d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n  wallNormal.multTo(d);\n  velocity.subFrom(wallNormal);\n}","map":{"version":3,"names":["colorToRgb","getStyleFromRgb","Vector","getDistances","drawPolygonMask","context","rawData","stroke","color","beginPath","moveTo","x","y","_iterator","_createForOfIteratorHelper","_step","s","n","done","item","value","lineTo","err","e","f","closePath","strokeStyle","lineWidth","width","drawPolygonMaskPath","path","position","translate","opacity","parsePaths","paths","scale","offset","_a","res","_iterator2","_step2","segments","element","pathSegList","len","numberOfItems","p","i","segment","getItem","svgPathSeg","window","SVGPathSeg","pathSegType","PATHSEG_MOVETO_ABS","PATHSEG_LINETO_ABS","PATHSEG_CURVETO_CUBIC_ABS","PATHSEG_CURVETO_QUADRATIC_ABS","PATHSEG_ARC_ABS","PATHSEG_CURVETO_CUBIC_SMOOTH_ABS","PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS","absSeg","PATHSEG_LINETO_HORIZONTAL_ABS","PATHSEG_LINETO_VERTICAL_ABS","PATHSEG_LINETO_REL","PATHSEG_MOVETO_REL","PATHSEG_CURVETO_CUBIC_REL","PATHSEG_CURVETO_QUADRATIC_REL","PATHSEG_ARC_REL","PATHSEG_CURVETO_CUBIC_SMOOTH_REL","PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL","relSeg","PATHSEG_LINETO_HORIZONTAL_REL","PATHSEG_LINETO_VERTICAL_REL","PATHSEG_UNKNOWN","PATHSEG_CLOSEPATH","push","calcClosestPtOnSegment","s1","s2","pos","_getDistances","dx","dy","_getDistances2","dxx","dyy","t","Math","pow","isOnSegment","segmentBounce","start","stop","velocity","_getDistances3","wallAngle","atan2","wallNormal","create","sin","cos","d","multTo","subFrom"],"sources":["C:/Users/prana/OneDrive/Desktop/Misc/officialwebsite/node_modules/tsparticles/esm/Plugins/PolygonMask/Utils.js"],"sourcesContent":["import { colorToRgb, getStyleFromRgb } from \"../../Utils/ColorUtils\";\nimport { Vector } from \"../../Core/Utils/Vector\";\nimport { getDistances } from \"../../Utils/NumberUtils\";\nexport function drawPolygonMask(context, rawData, stroke) {\n    const color = colorToRgb(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.beginPath();\n    context.moveTo(rawData[0].x, rawData[0].y);\n    for (const item of rawData) {\n        context.lineTo(item.x, item.y);\n    }\n    context.closePath();\n    context.strokeStyle = getStyleFromRgb(color);\n    context.lineWidth = stroke.width;\n    context.stroke();\n}\nexport function drawPolygonMaskPath(context, path, stroke, position) {\n    context.translate(position.x, position.y);\n    const color = colorToRgb(stroke.color);\n    if (!color) {\n        return;\n    }\n    context.strokeStyle = getStyleFromRgb(color, stroke.opacity);\n    context.lineWidth = stroke.width;\n    context.stroke(path);\n}\nexport function parsePaths(paths, scale, offset) {\n    var _a;\n    const res = [];\n    for (const path of paths) {\n        const segments = path.element.pathSegList, len = (_a = segments === null || segments === void 0 ? void 0 : segments.numberOfItems) !== null && _a !== void 0 ? _a : 0, p = {\n            x: 0,\n            y: 0,\n        };\n        for (let i = 0; i < len; i++) {\n            const segment = segments === null || segments === void 0 ? void 0 : segments.getItem(i);\n            const svgPathSeg = window.SVGPathSeg;\n            switch (segment === null || segment === void 0 ? void 0 : segment.pathSegType) {\n                case svgPathSeg.PATHSEG_MOVETO_ABS:\n                case svgPathSeg.PATHSEG_LINETO_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n                case svgPathSeg.PATHSEG_ARC_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS: {\n                    const absSeg = segment;\n                    p.x = absSeg.x;\n                    p.y = absSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n                    p.x = segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n                    p.y = segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_REL:\n                case svgPathSeg.PATHSEG_MOVETO_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n                case svgPathSeg.PATHSEG_ARC_REL:\n                case svgPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n                case svgPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL: {\n                    const relSeg = segment;\n                    p.x += relSeg.x;\n                    p.y += relSeg.y;\n                    break;\n                }\n                case svgPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n                    p.x += segment.x;\n                    break;\n                case svgPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n                    p.y += segment.y;\n                    break;\n                case svgPathSeg.PATHSEG_UNKNOWN:\n                case svgPathSeg.PATHSEG_CLOSEPATH:\n                    continue;\n            }\n            res.push({\n                x: p.x * scale + offset.x,\n                y: p.y * scale + offset.y,\n            });\n        }\n    }\n    return res;\n}\nexport function calcClosestPtOnSegment(s1, s2, pos) {\n    const { dx, dy } = getDistances(pos, s1), { dx: dxx, dy: dyy } = getDistances(s2, s1), t = (dx * dxx + dy * dyy) / (dxx ** 2 + dyy ** 2), res = {\n        x: s1.x + dxx * t,\n        y: s1.x + dyy * t,\n        isOnSegment: t >= 0 && t <= 1,\n    };\n    if (t < 0) {\n        res.x = s1.x;\n        res.y = s1.y;\n    }\n    else if (t > 1) {\n        res.x = s2.x;\n        res.y = s2.y;\n    }\n    return res;\n}\nexport function segmentBounce(start, stop, velocity) {\n    const { dx, dy } = getDistances(start, stop), wallAngle = Math.atan2(dy, dx), wallNormal = Vector.create(Math.sin(wallAngle), -Math.cos(wallAngle)), d = 2 * (velocity.x * wallNormal.x + velocity.y * wallNormal.y);\n    wallNormal.multTo(d);\n    velocity.subFrom(wallNormal);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}